# nand2tetris
Completed Project files for Nand2Tetris.org 
Tips for completing the projects:

PLEASE NOTE THAT ALL PROJECT FILES ARE IN THE MASTER BRANCH OF THIS REPO.

Chapter 1: I found it helpful to create an Excel workbook of truth tables for each of the basic chips.  As I was building a new chip, I would reference the prior ones to see how they could be manipulated to provide the necessary output.  There is a copy of my Excel file with notes at the root of the project folder in this repo.

Chapter 2: Building the ALU
There are a couple of learning unlocks that I discovered on the way that allowed me to greatly simplify the code and build the ALU without helper chips and only using the built-in chips from Chapters 1 and 2.
* When considering how to provide conditional (if/then) functionality, take a hard look at the Multiplexor chip Mux.  
* When implementing the ng and zr output signals, you may want to create a subbus from an internal pin.  Subbussing internal pins is not supported by the Hardware Simulator.  To work around this limitation, I initial built some helper chips and was able to successfully complete the assignment, knowing that approach was not recommended by the instructors.  The missing piece of information is documented in the Survival Guide but I didn't grok it right away.  it is possible to create mutiple outputs from a chip.  For example, And16 (a=a, b=b, out=out, out[15]=t1, out[0..7]=tlsb, out[8...15]= tmsb, and so on).  With this bit of knowledge, you should be able to create all the additional logic necessary for the ng and zr signal outputs.

Chapter 3: Memory
* All of the needed clues for the project are described in the videos.
* First time using DMux8Way as a building block to pass the load input to the right chip
* First time using Mux8Way as a building block to determine which Register or RAM to read
* Note that the final RAM chip RAM16K just needs 4 RAM4K chips.  The others required 8.

Chapter 4:
* See comments in the code.

Chapter 5:
* When building the Memory chip, remember to use the built in Screen and Keyboard chips vs. creating your own with RAM and Register chips.
* The CPU chip is by far the most difficult.  I tried to work out the control bits and logic on paper and was able to get close enough to fix the errors generated by the test script.
* While working on this assignment, I heavily referenced the slides (45-47) from chapter 4 https://b1391bd6-da3d-477d-8c01-38cdf774495a.filesusr.com/ugd/56440f_12f488fe481344328506857e6a799f79.pdf as well as the circuit diagram slides 45-48 from chapter 5 https://b1391bd6-da3d-477d-8c01-38cdf774495a.filesusr.com/ugd/56440f_96cbb9c6b8b84760a04c369453b62908.pdf
* Hint: I found it helpful to rename the instruction[0..15] bits to conform to the Hack language specification 1 1 1 a c1 c2 c3 c4 c5 c6 d1 d2 d3 j1 j2 j3.  For example, And (a=instruction[5], b=true, out=d1) renames the index 5 instruction bit to d1 which matches the spec.
* Hint: Place on the chips and their interfaces in the script first and connect the inputs and outputs to the circuit diagram. Fill in the control logic as the next step.
* Hint: the ALU output bits are useful for controling the program counter pc chip
* Hint: the inputs for the ALU are very simple and straight forward in contrast to those for the Mux16, Register and Program Control chips. You will need to use some logic gates to derive most of those controls.
* Hint: to determine how to chose between the A register and the M memory input for the ALU input, carefully study the hack language spec in chapter 4 for the C instruction specification.

Chapter 6:
* The video series for this week's lessons are a bit repetitive but worth viewing in its entirety.
* I followed the recommended software architecture and approach.  My assembler is built in R.
* The recommended approach is to process the .asm file in 2 passes.  Pass 1 handles the user defined program labels, Pass two codes instructions and handles assignment of new memory locations.   I initially made the mistake of dealing with the memory location allocation in pass 1 but that approach wont work because you don't know whether a @USER_NAMED_ADDRESS is a program line label or a new user defined variable during the first pass.
* I used a lot of print to console statements to track program flow and outputs of intermediate operations.  Also, the provided Assember utility stops processing when there is a comparison error.  Comparing the machine code line at the point helped me find the errors in my logic.
* I used Dictionary objects to store the mappings.  Maintaining only 1 symbol dictionary for built-in symbols, program labels and user defined variables simplified the logic of the program.  I maintained separte dictionaries for jump, dest and comp mappings.  The comp dictionary included the a and c1-c6 mappings combined.

Chapters 7 & 8:
* The goal of these chapters is to implement a translator to take vm code and turn into assembler.  There are specific instructions in each module on how to implement but I encounted subtleties that weren't apparent to me from the start.  I often needed to refactor my code once my understanding improved.
* There are several discussions in the forum that were helpful.  For example, the implementation of Pop isn't intuitive.  There is an option to use one of the registers like R13 to host an intermediate calculation, but there is a more clever way to implement without it.  Conceptually, the straight forward way to implement requires that one use the D register to hold the stack value to be popped and the address of the memory location to push it to.  In order to solve, I needed to change my thinking of how I was using both the Stack and the D register.  There is a good forum thread entitled Is Pop Even Possible that has the clues.  Although it still took time to figure it out.  In summary, there are some intermediate vaules to store in D and on the Stack using addition and subtraction that allow you to manage swap values around.  For example if v1 and v2 are the values, then if D holds v1 and SP holds v1 + v2, you can always get back to v1 and v2 using subtraction.  
* The call and return functions are tricky.  In the instruction videos, they downplay the use of NestedCall test.  But actually, the test and the supporting documentation, particularly the map of the stack at each jump in the execution is immensely helpful. 
* The bootstrapping code and when and how to implement it is another complication.  Please note that you CALL the bootstrap code not GOTO it.  Also, you only invoke it when processing a directory and not when processing a file.  
* There is a particular when to format the return labels in the slides that requires you to track the number of times a function has been called which makes sense, you don't want to return to the same point in the code if a function is called twice. I used a dictionary object to implement that.  I used the return label as the key and the times it hs been called as the value.
* The code I turned in is not optimized. There are lots of opportunity to simplify and create utility functions to encapsulated repeated assembly code sequences such as increment/decrement stack pointer.

Chapter 9:
* The goal of this project is to build an application in the Jack language.  I chose to build a NIM game.  
* Deallocating stack / heap space is important.  Literal strings are never deallocated.  I experienced overflow errors because of this fact.  ended up storing all my strings in variables and deallocating them at the end of each function.  The same applies for Array variables.  deallocate at the end of each function.
* Pretty proud of the application I built.  Excercised all the aspects of the language.

Chapter 10:
* The goal is to parse a Jack file into an xml file tagged according to the grammar of the Jack language.  
* Difficult assignment.  Took many hours to complete.  Generating the xml file is just a validation.  The goal is to build a state model for each token.
* Parsing the multiline comments was a challenge.  Also, do not recommend separating the lines of commands by spaces.  Rather parse by each character.
* Approach taken is to parse each line and build a "stack" of tokens.  Then pop each token for processing.  I maintained a reference to both the current token and the next token

Chapter 11:
* Definitely the most difficult assignment so far.  It helped to compile the test programs using the JackCompiler.bat utility and compare output between compilers.  Note that JackCompiler.bat uses a different approach for if statement control flow than is described in the lectures which makes line by line comparison difficult.
* I ended up making extensive changes to the compilation engine to handle the vm code generation.
* Needed to consult posts on how to distinguish between function calls and method calls, expecially for Pong.  For example draw() is a method call in Bat and Ball classes.  Anything without an object or class identifier is treated as a method call.  Found that in the nand2tetris forum on chapter 11. http://nand2tetris-questions-and-answers-forum.32033.n3.nabble.com/Differentiating-functions-methods-and-constructors-td4026430.html

