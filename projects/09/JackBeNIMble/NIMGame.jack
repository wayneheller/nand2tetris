/**
 * Implements the Jack Be NIMble game.
 * This game consists of removing items from heaps
 * The person who removes the last item from the last heap either wins or loses
 * depending on the game type
 * The user defines the number of heaps and the size of each heap
 * The user also defines whether picking the last item wins or loses the game
 * 
 */

class NIMGame {
   field Array heaps;         // the collection of heap objects in the game
   field int numHeaps;        // the number of heaps in the game
   field int NimSum;          // the NimSum of all the heaps in the game
   field int gameType;        // 0 = taking last item wins; 1 = taking last item loses
                        

   /** Constructs a new NIM Game. */
   constructor NIMGame new(int Aheaps, Array AheapSizes, int AgameType) {
      var int i;
      let i = 0;

      let gameType = AgameType;
      let numHeaps = Aheaps;
      let heaps = Array.new(numHeaps);

      while (i < numHeaps) {
         let heaps[i] = Heap.new(AheapSizes[i]);
         let i = i + 1;
      }
      return this;
   }

   /** Disposes this game. */
   method void dispose() {
      var Heap heap;
      var int i;
      let i = 0;
      while (i < numHeaps) {
         let heap = heaps[i];
         //do heaps[i].dispose();
         do heap.dispose();
         let i = i + 1;
      }
      do Memory.deAlloc(this);
      return;
   }

   /** Runs the game: handles the user's inputs  */
   method void play() {
      
     return;
   }

   method void calcNimSum() {
      var int i, a, b;
      var Heap heap;

      let i = 1;
      let heap = heaps[0];
      let a = heap.getSize();
      while (i < numHeaps) { 
         let heap = heaps[i];
         let b = heap.getSize();
         let a = Utils.Xor(a, b);
         let i = i + 1;
      }
      let NimSum = a;
      return;
   }

   method boolean isNearEnd() {  // For gameType = 1, the strategy changes slightly near the end of the game
      var int i, s;              // where end of the game means there is only 1 heap with an item count greater than 1
      var Heap heap;
      var int cntLrgHeaps;        // count of heaps with more than 1 item

      let cntLrgHeaps = 0;
      while (i < numHeaps) {
         let heap = heaps[i];
         let s = heap.getSize();
         if (s > 1) {
            let cntLrgHeaps = cntLrgHeaps + 1;
         }
         let i = i + 1;
      }
      return((cntLrgHeaps < 2));
   }

   method int calcHeapsRemaining() { // returns the total number of heaps with more than 0 items
      var int i, s;
      var int cntHeaps;
      var Heap heap;

      let cntHeaps = 0;
      while (i < numHeaps) {
         let heap = heaps[i];
         let s = heap.getSize();
         if (s > 0) {
            let cntHeaps = cntHeaps + 1;
         }
         let i = i + 1;
      }
      return(cntHeaps);
   }

   method int findHeapToReduce() {
      var int i, s;
      var int maxIdx, maxSize;
      var Heap heap;
      var int heapNimSum;

      let i = 0;
      if ((NimSum = 0) | ((gameType = 1) & isNearEnd()))  { // The human player has the advantage and there is no clear best next move at this time
                                                            // Strategy: Find the heap with the greatest number of items and decrement by 1
                                                            // For gameType = 1, the strategy changes slightly near the end of the game
                                                            // where end of the game means there is only 1 heap with an item count greater than 1

         let maxIdx = 0;            // The index of the heap with the maximum size
         let maxSize = 0;           // The size of the largest heap
         while (i < numHeaps) {
            let heap = heaps[i];
            let s = heap.getSize();
            if (s > maxSize) {
               let maxIdx = i;
               let maxSize = s;
            }
            let i = i + 1;
         }
         return(maxIdx);
      }

      while (i < numHeaps) {        // The computer player has the advantage and the following code will determine which heap to reduce
         let heap = heaps[i];
         let s = heap.getSize();
         let heapNimSum = Utils.Xor(s, NimSum);
         if (heapNimSum < s) {
            return(i);
            }
         else {
            let i=i+1;
            }
      }
      return(numHeaps + 1);  // returns a value to indicate that no preferred move is found, this condition should never be met
   }

   method int calcHeapReduction(int idxHeap) {
      var int s;
      var Heap heap;
      var int heapsRemaining;             // The number of heaps with at least 1 item
      var boolean oddNumHeapsRemaining;   // True if there are an odd number of heaps remaining

      if (NimSum = 0) {                   // The human player has the advantage and there is no clear best next move at this time
          return(1);                      // Strategy: Find the heap with the greatest number of items and decrement by 1
      }

      if ((gameType = 1) & isNearEnd()) {        // if there is an odd number of heaps remaining, leave one item in the heap
                                                  // if even, remove the entire heap
         let heapsRemaining = calcHeapsRemaining();
         let oddNumHeapsRemaining = Utils.isOdd(heapsRemaining);
         let heap = heaps[idxHeap];
         let s = heap.getSize();
         if (oddNumHeapsRemaining) {
            return(s-1);
         }
         else {
            return(s);
         }

      }

      else {                              // This is the next best move to retain a winning position
         let heap = heaps[idxHeap];
         let s = heap.getSize();
         return(s - Utils.Xor(s, NimSum));  // return the different between the heap size and the heap Nim sum
      }
   }


   /** Diagnostis */
   method void describe() {
      var int i;
      var int s;
      var Heap heap;
      var int HeapToReduce, Reduction;
      let i = 0;
      do Output.moveCursor(0,0);
      do Output.printString("Number of heaps: "); do Output.printInt(numHeaps);
      
      
      while (i < numHeaps) {
         do Output.println();
         let heap = heaps[i];
         let s = heap.getSize();
         do Output.printString("The size of heap "); do Output.printInt(i); do Output.printString(" is "); do Output.printInt(s);
         let i = i + 1;
      }
      do calcNimSum();
      do Output.println();
      do Output.printString("The Nim Sum of all the heaps is: "); do Output.printInt(NimSum);
      let HeapToReduce = findHeapToReduce();
      do Output.println();
      do Output.printString("The heap to reduce is: "); do Output.printInt(HeapToReduce);
      let Reduction = calcHeapReduction(HeapToReduce);
      do Output.println();
      do Output.printString("The heap reduction is: "); do Output.printInt(Reduction);
      let heap = heaps[HeapToReduce];
      do heap.reduce(Reduction);
      do Output.println();
      do Output.printString("The new heap size is; "); do Output.printInt(heap.getSize());

   return;
   }
}